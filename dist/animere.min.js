/**
 * Animere.js - CSS-Driven Scroll-Based Animations
 *
 * @version 1.0.0
 * @author Johann Schopplich
 * @license MIT
 */
export default class{constructor({prefix:e="animere",offset:t=.2,watchDOM:r=!1}={}){this.prefix=e,this.offset=t,this.supportsScroll()&&(this.prefersReducedMotion()||(Array.from(document.querySelectorAll(`[data-${this.prefix}]`)).forEach(e=>{this.intersectOnScroll(e)}),r&&window.addEventListener("DOMContentLoaded",()=>{this.onDOMContentChanges()})))}animateCSS(e,t,r="animate__"){return new Promise((s,i)=>{const n=`${r}${t}`;e.classList.add(r+"animated",n),e.addEventListener("animationend",(function t(){e.classList.remove(r+"animated",n),e.removeEventListener("animationend",t),s("Animation ended")}))})}intersectionObserverCallback(e,t){e.forEach(e=>{if(!e.isIntersecting)return;const r=e.target;Object.keys(r.dataset).filter(e=>e!==this.prefix&&e.startsWith(this.prefix)).forEach(e=>{const t="--animate-"+e.slice(this.prefix.length).toLowerCase();r.style.setProperty(t,r.dataset[e])}),r.style.visibility=null,this.animateCSS(r,r.dataset[""+this.prefix]),t.unobserve(r)})}intersectOnScroll(e){e.style.visibility="hidden";new IntersectionObserver(this.intersectionObserverCallback.bind(this),{root:null,rootMargin:"0px",threshold:this.offset}).observe(e)}onDOMContentChanges(){new MutationObserver(e=>{e.forEach(e=>{const t=e.addedNodes;t&&Array.from(t).forEach(e=>{this.intersectOnScroll(e)})})}).observe(document.body,{childList:!0,subtree:!0})}prefersReducedMotion(){return window.matchMedia("(prefers-reduced-motion: reduce)").matches}supportsScroll(){return"onscroll"in window&&!/(gle|ing)bot/.test(navigator.userAgent)}}
